namespace: "alpha"
tenants: ["AV"]
envName: "alpha"
# This would be applied to all the java m/s and node m/s
applicationProfile: "k8s"
environmentProfile: "DEV" # STAG, DEV, PROD
#dockerRegistry: "ibsbox:5000/icargo-docker-local"
dockerRegistry: "harbor.ibsplc.com/icargo"
cloudConfigServerUrl: "http://neo-config-server/config-service"
configServerArtifactId: "neo-config-server"
enableGroupedDeployment: false
# Some Defaults
default:
  containerPort: 8080
  processType: "JAVA"
  javaMemoryProfile: "JavaHugeMemArgs"
  cpuProfile: "Default"
  healthEndpoint: "/health"

# Smart Loadbalacer to proxy requests based on application versions for blue-green deployment
smartLoadbalancer:
  enabled: false
  image: "icargo-neo-slb:v1.1.7"
  port: 2080

# Crashdump support
crashDumps:
  enabled: true
  mountPath: "/icargo-crash-dumps" # Mount path of the volume inside the pod
  hostPath: "/icargo-crash-dumps"  # The directory in the node which is mounted ( will be created if not present )

# Image pull secrets
dockerConfig:
  "harbor.ibsplc.com":
    username: "robot$icargo+icargo_lh_cvc"
    password: "SI0D8PmbgEliqNGgGTr3php3Yc0NrMmb"

# The options can be overriden at a service level as well.
environment:
  DEV:
    upgradeStrategy: "RollingUpdate"
    numberOfReplicas: 1
    autoScalingEnabled: false
    replicaEnabled: false
    JavaSmallMemArgs: "-Xms96M -Xmx96M -XX:+UseG1GC -XX:+ExitOnOutOfMemoryError"
    JavaDefaultMemArgs: "-Xms128M -Xmx128M -XX:+UseG1GC -XX:+ExitOnOutOfMemoryError"
    JavaHugeMemArgs: "-Xms256M -Xmx256M -XX:+UseG1GC -XX:+ExitOnOutOfMemoryError"
    JavaVeryHugeMemArgs: "-Xms512M -Xmx512M -XX:+UseG1GC -XX:+ExitOnOutOfMemoryError"
  PROD:
    upgradeStrategy: "RollingUpdate"
    numberOfReplicas: 3
    autoScalingEnabled: true
    replicaEnabled: true
    JavaSmallMemArgs: "-Xms128M -Xmx128M -XX:+UseG1GC"
    JavaDefaultMemArgs: "-Xms256M -Xmx256M -XX:+UseG1GC"
    JavaHugeMemArgs: "-Xms512M -Xmx512M -XX:+UseG1GC"

# Separate ingress for web and webservice
ingress:
  AV:
    devIngress: true # Should a separate ingress be created for private API and bff endpoints for dev testing
    ingressClassName: "nginx-alpha"
    host: "k8s-nginxalp-icargong-ed546127d1-89f64463d339106d.elb.ap-south-1.amazonaws.com"

# custom deployments properties
deployments:
  neo-config-server:
    javaMemoryProfile: 'JavaSmallMemArgs'
    serviceName: 'neo-config-server'
  neo-booking-business:
    javaMemoryProfile: 'JavaVeryHugeMemArgs'
  ebl-nbridge-base-rt:
    javaMemoryProfile: 'JavaVeryHugeMemArgs'

# Object creation flags, used during incremental deployments with single entry boms
disable:
  ns: true # for incremental deployment ns is created offline
  ingress: false
  ingressMaster: true # for incremental deployment master resource is created offline
  prometheus: false
  serviceaccounts: true # Incremental deployment

# Enable prometheus
prometheus:
  enabled: true
  alertRules:
    jdbcPool: false
    kafkaConsumer: false
    jvmHeap: false
    jvmThreads: false
    k8sWorkerNode: false
    pod: false
  alertManagerConfigOverrides:
    snowReceiver:
      enabled: false
      url: "http://neo-snow-adapter.icargo-system/snow-adapter/api/alertmanager/receive"

initDependencies:
  enabled: true
  image: "icargo-neo-init-controller:1.0.5"
  dependencies:
    #Deployment Name: Dependant Deployment Name
    neo-admin-business: "ebl-nbridge-base-rt,nbridge-base-security-rt"
    auth-service-business: "neo-admin-business"
    neo-msgbroker-eai-base-rt: "auth-service-business"
    neo-msgbroker-rt: "auth-service-business"
    neo-booking-business: "auth-service-business, neo-businessrules-business"
    icargo-neo-customs-business: "auth-service-business"
    neo-awb-business: "auth-service-business"
    neo-pricing-business: "auth-service-business"
#-------------- Values which are required for icargo-helm-monitoring charts -------------------#
elasticSearchUrl:
  - ip: "10.246.12.39"
    httpPort: 9020
    transportPort: 9030
crashCollector:
  remoteS3Directory: "/icargo-crash-dumps"
